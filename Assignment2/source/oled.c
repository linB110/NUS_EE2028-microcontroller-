#include "oled.h"
#include <string.h>

extern I2C_HandleTypeDef hi2c1;
uint8_t OLED_Buffer[1024];

// ASCII 字型資料表 (32~90)
static const uint8_t font5x8[][5] = {
		{0x00,0x00,0x00,0x00,0x00}, // ' ' space
		{0x00,0x00,0x5F,0x00,0x00}, // '!'
		{0x00,0x03,0x00,0x03,0x00}, // '"'
		{0x14,0x7F,0x14,0x7F,0x14}, // '#'
		{0x24,0x2A,0x7F,0x2A,0x12}, // '$'
		{0x23,0x13,0x08,0x64,0x62}, // '%'
		{0x36,0x49,0x55,0x22,0x50}, // '&'
		{0x00,0x05,0x03,0x00,0x00}, // '''
		{0x00,0x1C,0x22,0x41,0x00}, // '('
		{0x00,0x41,0x22,0x1C,0x00}, // ')'
		{0x14,0x08,0x3E,0x08,0x14}, // '*'
		{0x08,0x08,0x3E,0x08,0x08}, // '+'
		{0x00,0x50,0x30,0x00,0x00}, // ','
		{0x08,0x08,0x08,0x08,0x08}, // '-'
		{0x00,0x60,0x60,0x00,0x00}, // '.'
		{0x20,0x10,0x08,0x04,0x02}, // '/'

		// ASCII 48 '0' to 57 '9'
		{0x3E,0x51,0x49,0x45,0x3E}, // '0'
		{0x00,0x42,0x7F,0x40,0x00}, // '1'
		{0x42,0x61,0x51,0x49,0x46}, // '2'
		{0x21,0x41,0x45,0x4B,0x31}, // '3'
		{0x18,0x14,0x12,0x7F,0x10}, // '4'
		{0x27,0x45,0x45,0x45,0x39}, // '5'
		{0x3C,0x4A,0x49,0x49,0x30}, // '6'
		{0x01,0x71,0x09,0x05,0x03}, // '7'
		{0x36,0x49,0x49,0x49,0x36}, // '8'
		{0x06,0x49,0x49,0x29,0x1E}, // '9'

		// ASCII 58 ':' 到 64 '@'
		{0x00,0x36,0x36,0x00,0x00}, // ':'
		{0x00,0x56,0x36,0x00,0x00}, // ';'
		{0x08,0x14,0x22,0x41,0x00}, // '<'
		{0x14,0x14,0x14,0x14,0x14}, // '='
		{0x00,0x41,0x22,0x14,0x08}, // '>'
		{0x02,0x01,0x51,0x09,0x06}, // '?'
		{0x32,0x49,0x79,0x41,0x3E}, // '@'

		// ASCII 65 'A' to 90 'Z'
		{0x7E,0x11,0x11,0x11,0x7E}, // 'A'
		{0x7F,0x49,0x49,0x49,0x36}, // 'B'
		{0x3E,0x41,0x41,0x41,0x22}, // 'C'
		{0x7F,0x41,0x41,0x22,0x1C}, // 'D'
		{0x7F,0x49,0x49,0x49,0x41}, // 'E'
		{0x7F,0x09,0x09,0x09,0x01}, // 'F'
		{0x3E,0x41,0x51,0x51,0x72}, // 'G'
		{0x7F,0x08,0x08,0x08,0x7F}, // 'H'
		{0x00,0x41,0x7F,0x41,0x00}, // 'I'
		{0x20,0x40,0x41,0x3F,0x01}, // 'J'
		{0x7F,0x08,0x14,0x22,0x41}, // 'K'
		{0x7F,0x40,0x40,0x40,0x40}, // 'L'
		{0x7F,0x02,0x04,0x02,0x7F}, // 'M'
		{0x7F,0x02,0x04,0x08,0x7F}, // 'N'
		{0x3E,0x41,0x41,0x41,0x3E}, // 'O'
		{0x7F,0x09,0x09,0x09,0x06}, // 'P'
		{0x3E,0x41,0x51,0x21,0x5E}, // 'Q'
		{0x7F,0x09,0x19,0x29,0x46}, // 'R'
		{0x46,0x49,0x49,0x49,0x31}, // 'S'
		{0x01,0x01,0x7F,0x01,0x01}, // 'T'
		{0x3F,0x40,0x40,0x40,0x3F}, // 'U'
		{0x1F,0x20,0x40,0x20,0x1F}, // 'V'
		{0x7F,0x20,0x18,0x20,0x7F}, // 'W'
		{0x63,0x14,0x08,0x14,0x63}, // 'X'
		{0x03,0x04,0x78,0x04,0x03}, // 'Y'
		{0x61,0x51,0x49,0x45,0x43}, // 'Z'
};

void OLED_WriteCommand(uint8_t cmd)
{
    uint8_t data[2] = {0x00, cmd};  // 0x00 = Command Mode
    HAL_I2C_Master_Transmit(&hi2c1, OLED_ADDR, data, 2, HAL_MAX_DELAY);
}

void OLED_Init(void)
{
    HAL_Delay(1000);
    OLED_WriteCommand(0xAE);
    OLED_WriteCommand(0xD5); OLED_WriteCommand(0x80);
    OLED_WriteCommand(0xA8); OLED_WriteCommand(0x3F);
    OLED_WriteCommand(0xD3); OLED_WriteCommand(0x00);
    OLED_WriteCommand(0x40);
    OLED_WriteCommand(0x8D); OLED_WriteCommand(0x14);
    OLED_WriteCommand(0x20); OLED_WriteCommand(0x00);
    OLED_WriteCommand(0xA1);
    OLED_WriteCommand(0xC8);
    OLED_WriteCommand(0xDA); OLED_WriteCommand(0x12);
    OLED_WriteCommand(0x81); OLED_WriteCommand(0xCF);
    OLED_WriteCommand(0xD9); OLED_WriteCommand(0xF1);
    OLED_WriteCommand(0xDB); OLED_WriteCommand(0x40);
    OLED_WriteCommand(0xA4);
    OLED_WriteCommand(0xA6);
    OLED_WriteCommand(0xAF);
}

void OLED_Clear(void)
{
    memset(OLED_Buffer, 0, sizeof(OLED_Buffer));
}

void OLED_Update(void)
{
    for (uint8_t i = 0; i < 8; i++) {
        OLED_WriteCommand(0xB0 + i);
        OLED_WriteCommand(0x00);
        OLED_WriteCommand(0x10);

        uint8_t data[129];
        data[0] = 0x40;
        memcpy(&data[1], &OLED_Buffer[i * 128], 128);
        HAL_I2C_Master_Transmit(&hi2c1, OLED_ADDR, data, 129, HAL_MAX_DELAY);
    }
}

void OLED_DrawChar(uint8_t x, uint8_t y, char c)
{
    if (c < 32 || c > 90) c = '?';
    uint8_t index = c - 32;

    for (uint8_t i = 0; i < 5; i++) {
        OLED_Buffer[x + (y * 128) + i] = font5x8[index][i];
    }
    OLED_Buffer[x + (y * 128) + 5] = 0x00;
}

void OLED_DrawText(uint8_t x, uint8_t y, const char* text)
{
    while (*text) {
        OLED_DrawChar(x, y, *text++);
        x += 6;
    }
}

void OLED_DrawPixel(uint8_t x, uint8_t y) {
    if (x >= OLED_WIDTH || y >= OLED_HEIGHT) return;
    OLED_Buffer[x + (y / 8) * OLED_WIDTH] |= (1 << (y % 8));
}

void OLED_DrawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
    int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
    int err = dx + dy, e2;

    while (1) {
        OLED_DrawPixel(x0, y0);
        if (x0 == x1 && y0 == y1) break;
        e2 = 2 * err;
        if (e2 >= dy) { err += dy; x0 += sx; }
        if (e2 <= dx) { err += dx; y0 += sy; }
    }
}
